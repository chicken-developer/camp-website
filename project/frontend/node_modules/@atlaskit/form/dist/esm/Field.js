import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _typeof from "@babel/runtime/helpers/typeof";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useContext, useEffect, useMemo, useRef, useState } from 'react';
import { uid } from 'react-uid';
import invariant from 'tiny-invariant';
import { FormContext, IsDisabledContext } from './Form';
import FieldWrapper, { Label, RequiredIndicator } from './styled/Field';

function isEvent(event) {
  return Boolean(event && event.target);
}

function isFunction(x) {
  return typeof x === 'function';
}

// Provides the id of the field to message components.
// This links the message with the field for screen-readers.
export var FieldId = /*#__PURE__*/React.createContext(undefined);

function usePreviousRef(current) {
  var ref = useRef(current); // will be updated on the next render

  useEffect(function () {
    ref.current = current;
  }); // return the existing current (pre render)

  return ref;
}

function isShallowEqual(previousValue, currentValue) {
  if (previousValue === currentValue) {
    return true;
  } // not checking functions


  if (typeof previousValue === 'function' && typeof currentValue === 'function') {
    return true;
  }

  if (Array.isArray(previousValue) && Array.isArray(currentValue)) {
    return JSON.stringify(previousValue) === JSON.stringify(currentValue);
  }

  if (_typeof(previousValue) === 'object' && _typeof(currentValue) === 'object') {
    return JSON.stringify(previousValue) === JSON.stringify(currentValue);
  }

  return false;
}

function Field(props) {
  var registerField = useContext(FormContext);
  var isDisabled = useContext(IsDisabledContext) || props.isDisabled;
  var defaultValue = isFunction(props.defaultValue) ? props.defaultValue() : props.defaultValue;

  var _useState = useState({
    fieldProps: {
      onChange: function onChange() {},
      onBlur: function onBlur() {},
      onFocus: function onFocus() {},
      value: defaultValue
    },
    error: undefined,
    valid: false,
    meta: {
      dirty: false,
      dirtySinceLastSubmit: false,
      touched: false,
      valid: false,
      validating: false,
      submitting: false,
      submitFailed: false,
      error: undefined,
      submitError: undefined
    }
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var latestPropsRef = usePreviousRef(props);
  var latestStateRef = usePreviousRef(state);
  /**
   * HACK: defaultValue can potentially be an array or object which cannot be
   * passed directly into a `useEffect` dependency array, since it will trigger
   * the hook every time.
   */

  var hasDefaultValueChanged = isShallowEqual(latestPropsRef.current.defaultValue, props.defaultValue);
  useEffect(function () {
    if (process.env.NODE_ENV !== 'production' && !process.env.CI) {
      invariant(latestPropsRef.current.name, '@atlaskit/form: Field components have a required name prop');
    }

    function fieldStateToMeta() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        dirty: value.dirty || false,
        dirtySinceLastSubmit: value.dirtySinceLastSubmit || false,
        touched: value.touched || false,
        valid: value.valid || false,
        submitting: value.submitting || false,
        submitFailed: value.submitFailed || false,
        error: value.error,
        submitError: value.submitError,
        validating: !!value.validating
      };
    }

    var unregister = registerField(latestPropsRef.current.name, latestPropsRef.current.defaultValue, function (fieldState) {
      /** Do not update dirtySinceLastSubmit until submission has finished. */
      var modifiedDirtySinceLastSubmit = fieldState.submitting ? latestStateRef.current.meta.dirtySinceLastSubmit : fieldState.dirtySinceLastSubmit;
      /** Do not update submitFailed until submission has finished. */

      var modifiedSubmitFailed = fieldState.submitting ? latestStateRef.current.meta.submitFailed : fieldState.submitFailed;
      /** Do not use submitError if the value has changed. */

      var modifiedSubmitError = modifiedDirtySinceLastSubmit && latestPropsRef.current.validate ? undefined : fieldState.submitError;
      var modifiedError = modifiedSubmitError || (fieldState.touched || fieldState.dirty) && fieldState.error;
      /**
       * If there has been a submit error, then use logic in modifiedError to determine validity,
       * so we can determine when there is a submit error which we do not want to display
       * because the value has been changed.
       */

      var modifiedValid = modifiedSubmitFailed ? modifiedError === undefined : fieldState.valid;

      function getTransform(eventOrValue, currentValue) {
        if (latestPropsRef.current.transform) {
          return latestPropsRef.current.transform(eventOrValue, currentValue);
        }

        if (isEvent(eventOrValue)) {
          var currentTarget = eventOrValue.currentTarget;

          if (currentTarget.type === 'checkbox') {
            //@ts-expect-error TODO Fix legit TypeScript 3.9.6 improved inference error
            if (currentTarget.checked) {
              return currentTarget.value || true;
            }

            return currentTarget.value ? undefined : false;
          } else if (currentTarget) {
            return currentTarget.value;
          }
        } else {
          return eventOrValue;
        }
      }

      setState({
        fieldProps: {
          onChange: function onChange(e) {
            fieldState.change(getTransform(e, fieldState.value));
          },
          onBlur: fieldState.blur,
          onFocus: fieldState.focus,
          value: fieldState.value
        },
        error: modifiedError || undefined,

        /**
         * The following parameters are optionally typed in final-form to indicate that not all parameters need
         * to be subscribed to. We cast them as booleans (using || false), since this is what they are semantically.
         */
        valid: modifiedValid || false,
        meta: fieldStateToMeta(fieldState)
      });
    }, {
      dirty: true,
      dirtySinceLastSubmit: true,
      touched: true,
      valid: true,
      submitting: true,
      submitFailed: true,
      value: true,
      error: true,
      submitError: true,
      validating: true
    }, {
      getValidator: function getValidator() {
        return function validate(value, formState, fieldState) {
          var supplied = latestPropsRef.current.validate;

          if (supplied && fieldState) {
            return supplied(value, formState, fieldStateToMeta(fieldState));
          }
        };
      }
    });
    return unregister;
  }, [latestPropsRef, latestStateRef, registerField, props.name, hasDefaultValueChanged]);
  var fieldId = useMemo(function () {
    return props.id ? props.id : "".concat(props.name, "-").concat(uid({
      id: props.name
    }));
  }, [props.id, props.name]);

  var extendedFieldProps = _objectSpread(_objectSpread({}, state.fieldProps), {}, {
    name: props.name,
    isDisabled: isDisabled,
    isInvalid: Boolean(state.error),
    isRequired: Boolean(props.isRequired),
    'aria-invalid': state.error ? 'true' : 'false',
    'aria-labelledby': "".concat(fieldId, "-label ").concat(fieldId, "-helper ").concat(fieldId, "-valid ").concat(fieldId, "-error"),
    id: fieldId
  });

  return /*#__PURE__*/React.createElement(FieldWrapper, null, props.label && /*#__PURE__*/React.createElement(Label, {
    id: "".concat(fieldId, "-label"),
    htmlFor: fieldId
  }, props.label, props.isRequired && /*#__PURE__*/React.createElement(RequiredIndicator, {
    "aria-hidden": "true"
  }, "*")), /*#__PURE__*/React.createElement(FieldId.Provider, {
    value: fieldId
  }, props.children({
    fieldProps: extendedFieldProps,
    error: state.error,
    valid: state.valid,
    meta: state.meta
  })));
}

Field.defaultProps = {
  defaultValue: undefined,
  isDisabled: false
};
export default Field;