"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FieldId = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = _interopRequireWildcard(require("react"));

var _reactUid = require("react-uid");

var _tinyInvariant = _interopRequireDefault(require("tiny-invariant"));

var _Form = require("./Form");

var _Field = _interopRequireWildcard(require("./styled/Field"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isEvent(event) {
  return Boolean(event && event.target);
}

function isFunction(x) {
  return typeof x === 'function';
}

// Provides the id of the field to message components.
// This links the message with the field for screen-readers.
var FieldId = /*#__PURE__*/_react.default.createContext(undefined);

exports.FieldId = FieldId;

function usePreviousRef(current) {
  var ref = (0, _react.useRef)(current); // will be updated on the next render

  (0, _react.useEffect)(function () {
    ref.current = current;
  }); // return the existing current (pre render)

  return ref;
}

function isShallowEqual(previousValue, currentValue) {
  if (previousValue === currentValue) {
    return true;
  } // not checking functions


  if (typeof previousValue === 'function' && typeof currentValue === 'function') {
    return true;
  }

  if (Array.isArray(previousValue) && Array.isArray(currentValue)) {
    return JSON.stringify(previousValue) === JSON.stringify(currentValue);
  }

  if ((0, _typeof2.default)(previousValue) === 'object' && (0, _typeof2.default)(currentValue) === 'object') {
    return JSON.stringify(previousValue) === JSON.stringify(currentValue);
  }

  return false;
}

function Field(props) {
  var registerField = (0, _react.useContext)(_Form.FormContext);
  var isDisabled = (0, _react.useContext)(_Form.IsDisabledContext) || props.isDisabled;
  var defaultValue = isFunction(props.defaultValue) ? props.defaultValue() : props.defaultValue;

  var _useState = (0, _react.useState)({
    fieldProps: {
      onChange: function onChange() {},
      onBlur: function onBlur() {},
      onFocus: function onFocus() {},
      value: defaultValue
    },
    error: undefined,
    valid: false,
    meta: {
      dirty: false,
      dirtySinceLastSubmit: false,
      touched: false,
      valid: false,
      validating: false,
      submitting: false,
      submitFailed: false,
      error: undefined,
      submitError: undefined
    }
  }),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var latestPropsRef = usePreviousRef(props);
  var latestStateRef = usePreviousRef(state);
  /**
   * HACK: defaultValue can potentially be an array or object which cannot be
   * passed directly into a `useEffect` dependency array, since it will trigger
   * the hook every time.
   */

  var hasDefaultValueChanged = isShallowEqual(latestPropsRef.current.defaultValue, props.defaultValue);
  (0, _react.useEffect)(function () {
    if (process.env.NODE_ENV !== 'production' && !process.env.CI) {
      (0, _tinyInvariant.default)(latestPropsRef.current.name, '@atlaskit/form: Field components have a required name prop');
    }

    function fieldStateToMeta() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        dirty: value.dirty || false,
        dirtySinceLastSubmit: value.dirtySinceLastSubmit || false,
        touched: value.touched || false,
        valid: value.valid || false,
        submitting: value.submitting || false,
        submitFailed: value.submitFailed || false,
        error: value.error,
        submitError: value.submitError,
        validating: !!value.validating
      };
    }

    var unregister = registerField(latestPropsRef.current.name, latestPropsRef.current.defaultValue, function (fieldState) {
      /** Do not update dirtySinceLastSubmit until submission has finished. */
      var modifiedDirtySinceLastSubmit = fieldState.submitting ? latestStateRef.current.meta.dirtySinceLastSubmit : fieldState.dirtySinceLastSubmit;
      /** Do not update submitFailed until submission has finished. */

      var modifiedSubmitFailed = fieldState.submitting ? latestStateRef.current.meta.submitFailed : fieldState.submitFailed;
      /** Do not use submitError if the value has changed. */

      var modifiedSubmitError = modifiedDirtySinceLastSubmit && latestPropsRef.current.validate ? undefined : fieldState.submitError;
      var modifiedError = modifiedSubmitError || (fieldState.touched || fieldState.dirty) && fieldState.error;
      /**
       * If there has been a submit error, then use logic in modifiedError to determine validity,
       * so we can determine when there is a submit error which we do not want to display
       * because the value has been changed.
       */

      var modifiedValid = modifiedSubmitFailed ? modifiedError === undefined : fieldState.valid;

      function getTransform(eventOrValue, currentValue) {
        if (latestPropsRef.current.transform) {
          return latestPropsRef.current.transform(eventOrValue, currentValue);
        }

        if (isEvent(eventOrValue)) {
          var currentTarget = eventOrValue.currentTarget;

          if (currentTarget.type === 'checkbox') {
            //@ts-expect-error TODO Fix legit TypeScript 3.9.6 improved inference error
            if (currentTarget.checked) {
              return currentTarget.value || true;
            }

            return currentTarget.value ? undefined : false;
          } else if (currentTarget) {
            return currentTarget.value;
          }
        } else {
          return eventOrValue;
        }
      }

      setState({
        fieldProps: {
          onChange: function onChange(e) {
            fieldState.change(getTransform(e, fieldState.value));
          },
          onBlur: fieldState.blur,
          onFocus: fieldState.focus,
          value: fieldState.value
        },
        error: modifiedError || undefined,

        /**
         * The following parameters are optionally typed in final-form to indicate that not all parameters need
         * to be subscribed to. We cast them as booleans (using || false), since this is what they are semantically.
         */
        valid: modifiedValid || false,
        meta: fieldStateToMeta(fieldState)
      });
    }, {
      dirty: true,
      dirtySinceLastSubmit: true,
      touched: true,
      valid: true,
      submitting: true,
      submitFailed: true,
      value: true,
      error: true,
      submitError: true,
      validating: true
    }, {
      getValidator: function getValidator() {
        return function validate(value, formState, fieldState) {
          var supplied = latestPropsRef.current.validate;

          if (supplied && fieldState) {
            return supplied(value, formState, fieldStateToMeta(fieldState));
          }
        };
      }
    });
    return unregister;
  }, [latestPropsRef, latestStateRef, registerField, props.name, hasDefaultValueChanged]);
  var fieldId = (0, _react.useMemo)(function () {
    return props.id ? props.id : "".concat(props.name, "-").concat((0, _reactUid.uid)({
      id: props.name
    }));
  }, [props.id, props.name]);

  var extendedFieldProps = _objectSpread(_objectSpread({}, state.fieldProps), {}, {
    name: props.name,
    isDisabled: isDisabled,
    isInvalid: Boolean(state.error),
    isRequired: Boolean(props.isRequired),
    'aria-invalid': state.error ? 'true' : 'false',
    'aria-labelledby': "".concat(fieldId, "-label ").concat(fieldId, "-helper ").concat(fieldId, "-valid ").concat(fieldId, "-error"),
    id: fieldId
  });

  return /*#__PURE__*/_react.default.createElement(_Field.default, null, props.label && /*#__PURE__*/_react.default.createElement(_Field.Label, {
    id: "".concat(fieldId, "-label"),
    htmlFor: fieldId
  }, props.label, props.isRequired && /*#__PURE__*/_react.default.createElement(_Field.RequiredIndicator, {
    "aria-hidden": "true"
  }, "*")), /*#__PURE__*/_react.default.createElement(FieldId.Provider, {
    value: fieldId
  }, props.children({
    fieldProps: extendedFieldProps,
    error: state.error,
    valid: state.valid,
    meta: state.meta
  })));
}

Field.defaultProps = {
  defaultValue: undefined,
  isDisabled: false
};
var _default = Field;
exports.default = _default;