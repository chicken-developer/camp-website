{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useEffect } from 'react';\nimport useLazyCallback from '@atlaskit/ds-lib/use-lazy-callback';\nimport usePreviousValue from '@atlaskit/ds-lib/use-previous-value';\nimport useStateRef from '@atlaskit/ds-lib/use-state-ref';\nimport { useExitingPersistence } from '@atlaskit/motion/exiting-persistence';\n/**\n *  ________________________________________________\n * | MAJOR VERSIONS WILL NOT KNOW ABOUT EACH OTHER! |\n *  ------------------------------------------------\n *\n * An array which holds references to all currently open modal dialogs.\n * This will only work for modal dialogs of the same major version,\n * as the reference will be different between them.\n *\n * E.g. V11 won't know about any from V12.\n */\n\nvar modalStackRegister = [];\n/**\n * Returns the position of the calling modal dialog in the modal dialog stack.\n * Stack index of `0` is the highest position in the stack,\n * with every higher number being behind in the stack.\n */\n\nexport default function useModalStack(_ref) {\n  var onStackChange = _ref.onStackChange;\n\n  var _useExitingPersistenc = useExitingPersistence(),\n      isExiting = _useExitingPersistenc.isExiting;\n\n  var _useStateRef = useStateRef(0),\n      _useStateRef2 = _slicedToArray(_useStateRef, 2),\n      stackIndexRef = _useStateRef2[0],\n      setStackIndex = _useStateRef2[1];\n\n  var currentStackIndex = stackIndexRef.current;\n  var previousStackIndex = usePreviousValue(stackIndexRef.current); // We want to ensure this function **never changes** during the lifecycle of this component.\n  // This is why it's assigned to a ref and not in a useMemo/useCallback.\n\n  var updateStack = useLazyCallback(function () {\n    var newStackIndex = modalStackRegister.indexOf(updateStack); // We access the stack index ref instead of state because this closure will always only\n    // have the initial state and not any of the later values.\n\n    if (stackIndexRef.current !== newStackIndex) {\n      setStackIndex(newStackIndex);\n      stackIndexRef.current = newStackIndex;\n    }\n  });\n  useEffect(function () {\n    var currentStackIndex = modalStackRegister.indexOf(updateStack);\n\n    if (!isExiting && currentStackIndex === -1) {\n      // We are opening the modal dialog.\n      // Add ourselves to the modal stack register!\n      modalStackRegister.unshift(updateStack);\n    }\n\n    if (isExiting && currentStackIndex !== -1) {\n      // We are closing the modal dialog using a wrapping modal transition component.\n      // Remove ourselves from the modal stack register!\n      // NOTE: Modal dialogs that don't have a wrapping modal transition component won't flow through here!\n      // For that scenario we cleanup when the component unmounts.\n      modalStackRegister.splice(currentStackIndex, 1);\n    } // Fire all registered modal dialogs to update their position in the stack.\n\n\n    modalStackRegister.forEach(function (cb) {\n      return cb();\n    });\n  }, [updateStack, isExiting]);\n  useEffect(function () {\n    return function () {\n      // Final cleanup just in case this modal dialog did not have a wrapping modal transition.\n      var currentStackIndex = modalStackRegister.indexOf(updateStack);\n\n      if (currentStackIndex !== -1) {\n        modalStackRegister.splice(currentStackIndex, 1);\n        modalStackRegister.forEach(function (cb) {\n          return cb();\n        });\n      }\n    };\n  }, [updateStack]);\n  useEffect(function () {\n    if (previousStackIndex === undefined) {\n      // Initial case that we don't need to notify about.\n      return;\n    }\n\n    if (previousStackIndex !== currentStackIndex) {\n      onStackChange(currentStackIndex);\n    }\n  }, [onStackChange, previousStackIndex, currentStackIndex]);\n  return currentStackIndex;\n}","map":null,"metadata":{},"sourceType":"module"}